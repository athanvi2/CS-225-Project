Link: https://openflights.org/data.html

Leading Question:
During the summer of 2022, chaos with air travel logistics left many passengers with their baggage and belongings dropped off at wrong airports. The expectation of returning these belongings was, as expected, on the airlines. But returning baggage is not just about minimizing time. Planning, scheduling, and all the associated costs of a flight are complex and expensive. How can these bags be most efficiently delivered considering the distance, time, and traffic on those paths as all those factors affect the cost of delivery of those bags? Basically, we are trying to find preferred routes. To answer this question we will use Dijkstra’s algorithm to calculate the shortest distance used to return the lost baggage from a given point A to point B. We will also utilize BFS to find the shortest path between two given airports. This is very helpful for more high traffic airports and will aid us in our goal to schedule specific flights for the purpose of moving baggage to the correct destination efficiently. Lastly, we will use PageRank as a sort of simulation if there is an issue with where the luggage has been moved and how to send it to the correct destination. 
 
Data Format:
The dataset is from OpenFlights.org which is an open-source tool that contains data regarding flights such as logging flights, tracking flights, and more! The source of this data is OurAirports which is a site that explores the world's airports. The size of the individual datasets varies. For example the data on airports contains information from over 10,000 airports, train stations, and ferry terminals around the world. The airline dataset contains information from 5,888 airlines and the other datasets contain ample amounts of data. We plan to use all the data in the dataset as opposed to only using a subset. The dataset we are using is in a CSV format and due to this, we will parse through the data points and store the data in a two dimensional array. We will go through each new line using the C++ getLine() method.

Data Correction:
Any lines of data that have missing or NULL sections will be deleted. Any missing values in the dataset we are using will contain the “\N” character so it will not be too difficult to parse the CSV and delete data with this character. If a line does have NULL values or missing values then we will not use the data for our project.

Data Storage:
We will be utilizing an unordered map to store our datasets. We can store airports locations and unique identifiers (such as location) as key-value pairs. We will also use an unordered map to aid us in creating our adjacency matrices for when we do PageRank and this map will contain vectors that represent a sort of array-like structure which is nice. We want to utilize unordered maps since the cost of search, insert, and delete from the hash table is O(1)! Due to the time complexity of unordered map operations being O(1) on average as compared to map operations which is O(log n) we are confident in our choice to use an unordered map. We want to use a two dimensional vector for our implementation of this. This vector will have the airport ID and also the information of each airport. We will also create a Graph class and extract the data for the adjacency matrix. Utilizing all this we will create a weighted graph and use 0 and 1’s to populate the adjacency matrix. 

Algorithm:
Djikstra Algorithm- Dijkstra's algorithm is an algorithm commonly used for finding the shortest paths between nodes in a graph. We would like to calculate the shortest distance to return the lost baggage from point A to point B. The target goal of efficiency is O(Elog(V)) where V is the number of vertices and E is the total number of edges. The expected inputs will be the current airport the baggage is at (representing as an integer) as well as the shortest path tree set that keeps track of vertices included in the shortest-path tree (representation of a weighted undirected graph) that we will assemble by reading from the CSV file of longitude and latitude and calculating the distances between airports. The expected output will return a vector representation of the traversal from point A to point B, the shortest path in terms of distance.
BFS - Shortest Path (Helpful for high traffic airports) This is a simple traversal for the purpose of discovering the shortest path between two given airports. This is helpful for airlines who decide to schedule specific flights for the purpose of moving baggage to the correct destination. Starting airport, End point airport, dataset of airports needs to be converted into a weighted, directed graph. Directions would signify if an airplane can go in that direction, and weights would signify the distance between two airports. Some simplifying assumptions are that we will consider distance to be an accurate indicator of time and that there are no layovers between connected flights. This will give the shortest path in distance between two given airports. It will give a vector of steps between airports
PageRank - This is to simulate if the companies randomly send luggages to be moved from the incorrect airport until it reaches a correct airport. We can calculate the frequency it takes for baggage to reach the correct airport. The idea for this algorithm is parallel to the idea if the company decides to not arrange "separate" flights for delivering these baggage. They just keep the baggage moving until it reaches the correct airport so it doesn't crowd the airport itself. The expected complexity for PageRank is O(N^2), but we will try to optimize the PageRank to something faster, but it is heavily dependent on the power iteration of the PageRank matrix. The input is dependent on the number of airports we are looking to add to our markov matrix or weighted directed graph. We will most likely use the dataset as it is to create the weighted, directed graph, if it has the connections between the airports. The expected output is to show the average iteration it takes for the baggage to reach a specific airport. Each airport will be marked with the average iterations needed to reach said airport. We can possibly use a hashmap where each airport is the key and the values are the average iterations to reach the correct airport.

Timeline:
We have approximately 5 weeks left to complete this project. The first week we have created a GitHub repository, completed the team contract and proposal. In Week 2 we will do some research specifically on Dijkstra’s Algorithm and PageRank since we want to be more comfortable and familiarized with them. We will also start the implementation of Dijkstra’s Algorithm since we are more familiar with it since it was taught in class. In Week 3 we will finish the implementation of Dijkstra’s algorithm and start implementing PageRank. In Week 4 we will finish implementing the PageRank algorithm and start doing BFS. Week 5 we will start doing the finishing touches for the BFS algorithm and wrap up our project and do last minute finishing touches. We will also ensure all our tests are passing and that everything looks ok!
