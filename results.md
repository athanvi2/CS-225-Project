
### Leading Question:
During the summer of 2022, chaos with air travel logistics left many passengers with their baggage and belongings dropped off at wrong airports. The expectation of returning these belongings was, as expected, on the airlines. But returning baggage is not just about minimizing time. Planning, scheduling, and all the associated costs of a flight are complex and expensive. How can these bags be most efficiently delivered considering the distance, time, and traffic on those paths as all those factors affect the cost of delivery of those bags?
To answer this question we will use Dijkstra’s algorithm to calculate the shortest distance used to return the lost baggage from a given point A to point B in the scenario that we are scheduling flights for the purpose of returning lost baggage. In this scenario, we want to minimize overall distance to spend as less fuel and minimize costs. We will also utilize Breadth First Search to find the shortest path between two given airports. This is very helpful for higher traffic airports and will aid us in the situation where we are adding luggage to pre-existing flights. Minimizing the amount of time extra luggage would have to be moved is the priority here, and since these flights are traveling regardless, we would prioritize number of steps over total distance. Lastly, we will use PageRank as a simulation if there is an issue with where the luggage has been moved and how to send it to the correct destination.
### Data Parsing & Graph Class: 
We needed to read the airports.dat and routes.dat CSV files, and store the information about airports and routes in our Graph class. Before doing so, using python, in the Cleaner.ipynb file, we cleaned up the data by removing duplicate and null values, extraneous empty spaces and commas, as well as dropping unnecessary columns of data not required for data analysis. We then stored clean CSV files in the data_cleaning folder.
Next we stored the node representation of airports in a vector of type airport which is defined in our airport.h file as a struct that holds important attributes of each node including airport name, code, latitude, longitude, index, and a vector of airports and their distances that are directly connected to the airport node. In order to do so, we call the CSVTwoD function on the airports CSV file and it parses and stores the rows and columns of the airports CSV file in a two-dimensional string vector. We then call the createAirport function which populates the airport struct with each node’s respective name, code, latitude and longitude.
Additionally, we stored the edge representation of routes between airports as a vector of pairs of airport types. To populate routes, we call the CSVTwoD function on the routes CSV file and it parses and stores the rows and columns of the routes CSV file in a two-dimensional string vector. We then call the ConvertCodeToAirport function on this vector which converts the string codes extracted from the CSV file to airport representations and stores them in routes. Once our routes vector is populated, we then populate each airport’s connected vector (in the airport struct). For each edge, we add a pair of the connecting airport and its direct distance. At this point we have populated the airport node vector, routes edge vector, and each airport’s struct data members. 
Lastly, we created an adjacency matrix represented as a two dimensional vector of type double. When inserting each airport in our airport vector, we gave each airport an index reflecting when it was inserted into the vector. The airport will then be referenced by its index. For example, if ORD is inserted as the fifth airport, it will be given a value of four for index (zero-indexing), and accessing the fourth row in the adjacency matrix will give a vector of ORD’s connection to every other airport. As a result, the intersection of the airport indices will return the distance between two airports, returning 0.0 if they are not directly connected. We utilized a function calcEdgeDistance in our constructor to determine the direct distance between two connected airports using latitude and longitude. 
In our proposal, we planned to use unordered maps for our data members, like the airports vector and adjacency matrix, as the cost of search, insert, and delete from the hash table is O(1). However, we decided to utilize vectors instead. Since we often were iterating over our adjacency matrix or airports vector, using an unordered map was noticeably inconvenient because there is no guarantee that airports will be iterated over in the order they were inserted in, and we believed this is a property that would greatly simplify writing our code. We also ran into issues with ordered maps. The addition of a struct type introduced significant issues with using maps. To use a map with a custom type, we would need to additionally define an Iterator/Compare for our struct. To write the iterator in the way we were planning to utilize iteration, we would have to include an index data member in our airport struct. However, at that point we could just as easily use a vector and work through the airports using the index variable, so we choose to just use vectors. Since the vast majority of the time when we were indexing into these vectors we were iterating over the entire vector anyway, there was no real benefit to the O(1) find of an unordered map. 
### Breadth First Search: 
The BFS followed a fairly standard graph traversal that sought to find the shortest distance in steps from a start to end. The function took in two parameters of type airport, representing the start and end airport. We utilize three main data structures in completing the BFS. First, we store the visited status of each airport in a vector of pairs, with each pair identifying the airport and its status. We also create another adjacency matrix that stores the same data as our original adjacency matrix along with the indirect distances that we will calculate and the status of each edge (discovery, cross, unvisited). Finally, we have a queue that takes in edges. At each node, we created edges for all the connected airports, utilizing a discovery and cross edge style of storing our traversal. When reaching a node that has not yet been visited, that edge is marked as discovery and all other edges that reach that node after will be marked cross. This traversal is very convenient as the path of discovery edges from the destination airport to the start airport will necessarily be the shortest path in steps between the two. After either the queue is empty (the destination node was not found) or we visit the destination node (the destination node was found), we utilize a back tracking helper function. If the queue was empty after completing the while loop, we know that the destination airport was not found and they are not even indirectly connected. Otherwise, we follow the discovery edges back to the starting airport and add up the distances.The Big O of our BFS is O(V2). 
### Dijkstra’s Algorithm: 
The Dijkstra function takes in two parameters of type airport, which represent the starting airport and destination. The function uses a vector implementation of a priority queue and each index stores the current airport, the distance of the current airport from the starting airport, and the previous airport traversed to before the current airport. Additionally, we store the minimum distance from the start with its corresponding airport and previous airport. While the queue is not empty, we search for the minimum distance on the priority queue and remove the minimum from the priority queue. We then check if the minimum’s current airport is the destination, which indicates that we’ve found the shortest distance from the starting point. If we are not at the destination, we will update the queue’s distances with the shortest path for each node from the start. If there is no path to the destination, the queue will empty, and the algorithm will return -1. Referring back to the project proposal, we mentioned that Dijsktra’s algorithm would run in squared-time and we were not able to achieve that. Our algorithm instead runs in cubed time. Due to time constraints, we were unable to increase the efficiency of this algorithm. Additionally, we mentioned that Dijkstra's algorithm will calculate the shortest distance used to return the lost baggage from a given point A to point B, and we accomplished that output.
### Page Rank: 
The algorithm was fairly straightforward as it followed the foundational concepts from our Linear Algebra classes. The way our algorithm works is that it uses the adjacency matrix to create a matrix of connections. It was trivial since if there was a distance cell that was not zero in the adjacency matrix, it meant there was a direct connection between two airports. Using the newly constructed, we generated the pagerank matrix with damping and scaling using a helper function. We then move into the actual pageRank function in which we come up with the “approximation” using an initial guess and iterating for 100 times to come up with a final guess for each of the airports. This guess is then normalized so it behaves more similarly to probability of being at a certain airport by using the norm. The heart of the algorithm is answered by the “PageRankResult” function that takes in the normalized vector, and a choice of how many of the top airports you desire to see! We use a priorityQueue to implement this function by creating a Compare struct that allows us to order the airports by their associated probabilities while we add them for our output format. The runtime complexity of our Page Rank algorithm is O(n+m), where n is the number of vertices (airports in our case) and m is the number of edges which basically represents the connections of each airport. The pagerank traverses through each airport and its connections to calculate each node’s probability, therefore each node/airport is visited once, and the edges are traversed twice due to the 2-way connection between 2 airports. Therefore, the Pagerank complexity is O(n+m), where the final guess was produced after 100 iterations of guessing, this could be changed which might make the runtime slower/faster, but the complexity will stay the same. This output of vectors of airports allows us to see the most important airports based on the connections they have with other airports and therefore the most probable airports for a luggage to end up at if lost.
### Test Suites: 
We included many test suites to test the functionality of our constructor, BFS, Dijkstra, and PageRank algorithms! Since we needed to know the expected output of every test case which was more time consuming and also challenging to test our huge CSV which contained thousands of data points, we opted to create some tests with a dataset we created. This smaller dataset included 10 airports and distances and helped us create some tests we could use to see if our functions/algorithms were actually doing what we intended them to do. The test files were a huge help to us! We also utilized CMake instead of just make, since we were most recently familiar with it through the CS 225 MP’s! CMake allows us to also utilize other libraries like Catch2. All that is necessary to run tests with our code is to create a build directory (mkdir build) and then get into the build folder (cd build) and run cmake .. ! All of our tests can be found in the tests folder (test.cpp).
### Result:
All the functions that we proposed in the project proposal work correctly and answer our leading question. Given a dataset of airports and routes, our project finds the shortest path between two airports based on numerical distance and least number of nodes, and ranks the airports based on popularity/high traffic. 
 
 


